import numpy as np
import requests
import scipy as sp

def getDrawsfromAPI():
    """
    Hits the Head/Tail API to get the coin flips

    Returns: 
    -an array representing 20 coin flips, 1 representing head and 0 representing tail
    """  
    response = requests.get(' https://24zl01u3ff.execute-api.us-west-1.amazonaws.com/beta')
    draws=np.array(response.json()["body"],dtype=str).tolist() 
    
    return draws
    
def constuct_drawHeadsArray():
    """
    Calls the  getDrawsfromAPI and construct an array of integer,
    where each integer is the number of heads for each of the 30 draws of 20 coin tosses each 

    Returns:
    -drawHeads:an array of integer representing number of heads in each draw
    """
    drawHeads=[]
    for i in range(30):
        draw=getDrawsfromAPI()
        print(draw)
        flipSequence=int(filter(str.isdigit, draw))
        count=0
        while(flipSequence>0):
          count+=flipSequence%10
          flipSequence=flipSequence/10
          #print(count)

        drawHeads.append(count)
    return drawHeads

def EM_EStep(drawHeads,biasA,biasB):
    """
    Input:
    -drawHeads: an array which indicate the number of head (and tail as each draw has 20 toss) returned for each of the 30 call of the API
    -biasA: bias of coin A i.e. the probability with which coin A gives a head
    -biasB: bias of coin B i.e. the probability with which coin B gives a head

    Calculates:
    -Calculates the likelihood of coin A and coin B from the given bias, and then probability of each coin A and B
    and using these values calculate the expected number of head and tails for each of the coin

    Return:
    -the expected value of heads and tails generated by coin A given the biases and the 30 draws
    -the expected value of heads and tails generated by coin B given the biases and the 30 draws
    """
    headsA,tailsA=0.0,0.0
    headsB,tailsB=0.0,0.0
    probabilityA,probabilityB=0.0,0.0

    for headFlips in drawHeads:
      likelihoodA=pow(biasA, headFlips) * pow(1-biasA, 20-headFlips)
      likelihoodB=pow(biasB, headFlips) * pow(1-biasB, 20-headFlips)
      probabilityA=likelihoodA/(likelihoodA+likelihoodB)
      probabilityB=likelihoodB/(likelihoodA+likelihoodB)
      headsA+=probabilityA*headFlips
      tailsA+=probabilityA*(20-headFlips)
      headsB+=probabilityB*headFlips
      tailsB+=probabilityB*(20-headFlips)

    return headsA,tailsA,headsB,tailsB

def EM_MStep(headsA,tailsA,headsB,tailsB):
    """
    Input:
    -headsA:number of heads that turned up when using coin A.Calculated from the E-step
    -tailsA:number of tails that turned up when using coin A.Calculated from the E-step
    -headsB:number of heads that turned up when using coin B.Calculated from the E-step
    -tailsB:number of tails that turned up when using coin B.Calculated from the E-step

    Returns:
    Parameters of the the model i.e the calculated biases for the coins A and B biasA and biasB
    -biasA: calculated bias of coin A
    -biasB: calculated bias of coin B
    """
    biasA = headsA / (headsA + tailsA)
    biasB = headsB / (headsB + tailsB)
    return biasA, biasB

def EMAlgorithm(initialBiasA,initialBiasB,maxIteration):
    """
    Input:
    -initialBiasA:assumed initial bias for coin A
    -initialBiasB:assumed initial bias for coin B
    -maxIteration:maximum iteration EM algorithm will run if not converged

    Returns:
    -the biases of coin A and B at convergence    

    """
    bias=[]
    epsilon=.0005
    biasA=initialBiasA
    biasB=initialBiasB
    drawHeads=constuct_drawHeadsArray()
    for iteration in range(maxIteration):
        print("Iteration\t%d::\tBias A:%0.2f\tBias B: %0.2f" % (iteration, biasA, biasB))
        headsA, tailsA, headsB, tailsB = EM_EStep(drawHeads, biasA, biasB)
        biasA, biasB = EM_MStep(headsA, tailsA, headsB, tailsB)
        if(len(bias)!=0 and abs(biasA-bias[len(bias)-1][0]<=epsilon) and abs(biasB-bias[len(bias)-1][1])<=epsilon):
            break
        
        bias.append((biasA,biasB))    
    return bias, (biasA,biasB)

output=EMAlgorithm(0.6,0.3,20)
print("The final parameters at convergence is\t%0.2f %0.2f" %(output[1][0],output[1][1] ))












